<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>River Flow - Arcanea Water Puzzle</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;800&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        :root {
            --water-primary: #4fc3f7;
            --water-dark: #0288d1;
            --water-glow: #80d8ff;
            --gold-light: #ffd700;
            --gold-medium: #ffb300;
            --bg-dark: #0a0a0f;
            --bg-card: #12121a;
            --bg-elevated: #1a1a28;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
            --text-muted: #606070;
            --success: #4caf50;
            --warning: #ff9800;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        .game-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(180deg, var(--bg-card) 0%, transparent 100%);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .back-btn {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1.25rem;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            color: var(--water-primary);
            border-color: var(--water-primary);
        }

        .game-title {
            font-family: 'Cinzel', serif;
            font-size: 1.25rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--water-primary), var(--gold-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .stat-pill {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            font-size: 0.875rem;
        }

        .stat-icon {
            font-size: 1rem;
        }

        .stat-value {
            font-weight: 600;
            color: var(--gold-light);
        }

        #game-container {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-river {
            width: 120px;
            height: 120px;
            position: relative;
            margin-bottom: 2rem;
        }

        .water-drop {
            position: absolute;
            width: 20px;
            height: 30px;
            background: linear-gradient(180deg, var(--water-primary), var(--water-dark));
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            animation: waterFlow 2s ease-in-out infinite;
        }

        .water-drop:nth-child(1) { left: 20px; animation-delay: 0s; }
        .water-drop:nth-child(2) { left: 50px; animation-delay: 0.3s; }
        .water-drop:nth-child(3) { left: 80px; animation-delay: 0.6s; }

        @keyframes waterFlow {
            0%, 100% { transform: translateY(0) scale(1); opacity: 1; }
            50% { transform: translateY(40px) scale(0.8); opacity: 0.7; }
        }

        .loading-text {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            color: var(--water-primary);
            margin-bottom: 0.5rem;
        }

        .loading-subtext {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .agent-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: var(--bg-card);
            border: 2px solid var(--water-primary);
            border-radius: 16px;
            padding: 1rem;
            z-index: 50;
            display: none;
            box-shadow: 0 0 30px rgba(79, 195, 247, 0.3);
            animation: slideUp 0.3s ease;
            max-height: 200px;
            overflow-y: auto;
        }

        .agent-panel.active {
            display: block;
        }

        @keyframes slideUp {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .agent-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .agent-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--water-primary), var(--gold-light));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
        }

        .agent-name {
            font-weight: 600;
            color: var(--water-primary);
        }

        .agent-role {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .agent-message {
            color: var(--text-secondary);
            line-height: 1.5;
            font-size: 0.9375rem;
        }

        .agent-close {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .success-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: var(--bg-card);
            border: 2px solid var(--gold-light);
            border-radius: 24px;
            padding: 2rem;
            text-align: center;
            z-index: 200;
            display: none;
            box-shadow: 0 0 60px rgba(255, 215, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .success-modal.active {
            display: block;
            animation: modalPop 0.5s ease forwards;
        }

        @keyframes modalPop {
            to { transform: translate(-50%, -50%) scale(1); }
        }

        .success-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            animation: bounce 1s ease infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .success-title {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            color: var(--gold-light);
            margin-bottom: 0.5rem;
        }

        .success-message {
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }

        .xp-reward {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid var(--gold-light);
            border-radius: 50px;
            font-family: 'Cinzel', serif;
            font-size: 1.25rem;
            color: var(--gold-light);
            margin-bottom: 1.5rem;
        }

        .success-btn {
            padding: 1rem 2rem;
            background: linear-gradient(135deg, var(--gold-light), var(--gold-medium));
            border: none;
            border-radius: 12px;
            color: #000;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .success-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(255, 215, 0, 0.3);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 150;
            display: none;
        }

        .modal-overlay.active {
            display: block;
        }

        .level-selector {
            position: fixed;
            top: 70px;
            left: 10px;
            background: var(--bg-card);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1rem;
            z-index: 40;
            display: none;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .level-selector.active {
            display: block;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
        }

        .level-btn {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: var(--bg-elevated);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Cinzel', serif;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .level-btn:hover {
            border-color: var(--water-primary);
            color: var(--water-primary);
        }

        .level-btn.completed {
            background: rgba(79, 195, 247, 0.2);
            border-color: var(--water-primary);
            color: var(--water-primary);
        }

        .level-btn.locked {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .mode-toggle {
            position: fixed;
            top: 70px;
            right: 10px;
            display: flex;
            gap: 0.5rem;
            z-index: 40;
        }

        .mode-btn {
            padding: 0.5rem 1rem;
            background: var(--bg-card);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.875rem;
        }

        .mode-btn:hover, .mode-btn.active {
            border-color: var(--water-primary);
            color: var(--water-primary);
        }

        @media (max-width: 768px) {
            .game-title { font-size: 1rem; }
            .stat-pill { padding: 0.375rem 0.75rem; font-size: 0.75rem; }
            .agent-panel { left: 10px; right: 10px; bottom: 10px; }
            .level-grid { grid-template-columns: repeat(4, 1fr); }
            .mode-toggle { flex-direction: column; }
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-river">
            <div class="water-drop"></div>
            <div class="water-drop"></div>
            <div class="water-drop"></div>
        </div>
        <div class="loading-text">River Flow</div>
        <div class="loading-subtext">Connecting the waters...</div>
    </div>

    <header class="game-header">
        <div class="header-left">
            <button class="back-btn" onclick="goBack()">‚Üê</button>
            <div class="game-title">üåä River Flow</div>
        </div>
        <div class="header-right">
            <div class="stat-pill">
                <span class="stat-icon">‚≠ê</span>
                <span class="stat-value" id="xpDisplay">0</span>
            </div>
            <div class="stat-pill">
                <span class="stat-icon">üß©</span>
                <span class="stat-value" id="levelDisplay">1</span>
            </div>
            <button class="back-btn" onclick="toggleLevelSelector()" style="font-size: 1rem;">üìã</button>
        </div>
    </header>

    <div class="mode-toggle">
        <button class="mode-btn active" id="normalMode" onclick="setMode('normal')">Normal</button>
        <button class="mode-btn" id="zenMode" onclick="setMode('zen')">Zen</button>
        <button class="mode-btn" id="timeMode" onclick="setMode('time')">Time</button>
    </div>

    <div class="level-selector" id="levelSelector">
        <div style="font-family: 'Cinzel', serif; margin-bottom: 1rem; color: var(--water-primary);">Select Level</div>
        <div class="level-grid" id="levelGrid"></div>
    </div>

    <div id="game-container"></div>

    <div class="agent-panel" id="agentPanel">
        <button class="agent-close" onclick="closeAgentPanel()">√ó</button>
        <div class="agent-header">
            <div class="agent-avatar" id="agentAvatar">üåä</div>
            <div>
                <div class="agent-name" id="agentName">River-Storyteller</div>
                <div class="agent-role" id="agentRole">The Flowing Narrator</div>
            </div>
        </div>
        <div class="agent-message" id="agentMessage">
            Welcome to the River. Click on pipes to rotate them and connect the water flow from source to destination. Each solved puzzle reveals part of an ancient story.
        </div>
    </div>

    <div class="modal-overlay" id="modalOverlay"></div>
    <div class="success-modal" id="successModal">
        <div class="success-icon">üåä</div>
        <div class="success-title" id="successTitle">Flow Complete!</div>
        <div class="success-message" id="successMessage">
            The waters connect and a story fragment is revealed.
        </div>
        <div class="xp-reward">
            <span>‚≠ê</span>
            <span id="xpReward">+50 XP</span>
        </div>
        <button class="success-btn" onclick="nextLevel()">Continue</button>
    </div>

    <script>
        // Game State
        const GameState = {
            xp: 0,
            currentLevel: 1,
            maxUnlocked: 1,
            mode: 'normal',
            gridSize: 6,
            tiles: [],
            waterFlowing: false,
            levelCompleted: false,
            timer: 0,
            timeLimit: 60,
            moves: 0,
            stories: [
                "In the beginning, there was only the Source...",
                "The waters flowed through ancient channels, carrying memories of forgotten civilizations...",
                "Each stream held a secret, each river a story waiting to be told...",
                "The aqueducts were built by hands long turned to dust, yet the water remembers...",
                "Through valleys and mountains, the flow continues eternal, connecting all things...",
                "In the depths, secrets sleep, waiting for the waters to reveal them...",
                "The cascade whispers truths that only the patient can hear...",
                "Where waters meet, destinies intertwine in the eternal dance...",
                "The flood brings both destruction and renewal, as all things must flow...",
                "At the ocean's edge, all rivers find their home, their stories complete..."
            ]
        };

        // Pipe Types: 0=empty, 1=straight, 2=corner, 3=tjunction, 4=cross, 5=source, 6=sink
        const PIPE_TYPES = {
            EMPTY: 0,
            STRAIGHT: 1,
            CORNER: 2,
            TJUNCTION: 3,
            CROSS: 4,
            SOURCE: 5,
            SINK: 6
        };

        // Phaser Config
        const config = {
            type: Phaser.AUTO,
            parent: 'game-container',
            width: window.innerWidth,
            height: window.innerHeight - 60,
            backgroundColor: '#0a0a0f',
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            scale: {
                mode: Phaser.Scale.RESIZE,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        let game;
        let gridGroup;
        let waterParticles;
        let timerText;
        let storyText;

        window.addEventListener('load', () => {
            game = new Phaser.Game(config);
            initLevelSelector();
            loadProgress();
            
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
                showAgentMessage('River-Storyteller', 'The Flowing Narrator', 'üåä',
                    'Welcome to River Flow! Click on pipes to rotate them. Connect the water from the source (üíß) to the destination (üåä). Complete the flow to reveal the story hidden in the waters.');
            }, 2000);
        });

        function preload() {
            const graphics = this.make.graphics();
            
            // Pipe textures
            const pipeColors = {
                empty: 0x1a1a28,
                pipe: 0x4fc3f7,
                water: 0x0288d1,
                source: 0x80d8ff,
                sink: 0xffd700
            };

            // Empty tile
            graphics.fillStyle(pipeColors.empty);
            graphics.fillRect(0, 0, 64, 64);
            graphics.lineStyle(2, 0x2a2a3a);
            graphics.strokeRect(0, 0, 64, 64);
            graphics.generateTexture('tile_empty', 64, 64);
            graphics.clear();

            // Straight pipe
            graphics.fillStyle(pipeColors.pipe);
            graphics.fillRect(20, 0, 24, 64);
            graphics.generateTexture('pipe_straight', 64, 64);
            graphics.clear();

            // Corner pipe
            graphics.fillStyle(pipeColors.pipe);
            graphics.fillRect(20, 0, 24, 44);
            graphics.fillRect(20, 20, 44, 24);
            graphics.generateTexture('pipe_corner', 64, 64);
            graphics.clear();

            // T-junction
            graphics.fillStyle(pipeColors.pipe);
            graphics.fillRect(20, 0, 24, 64);
            graphics.fillRect(0, 20, 32, 24);
            graphics.generateTexture('pipe_t', 64, 64);
            graphics.clear();

            // Cross
            graphics.fillStyle(pipeColors.pipe);
            graphics.fillRect(20, 0, 24, 64);
            graphics.fillRect(0, 20, 64, 24);
            graphics.generateTexture('pipe_cross', 64, 64);
            graphics.clear();

            // Source
            graphics.fillStyle(pipeColors.source);
            graphics.fillCircle(32, 32, 24);
            graphics.lineStyle(3, pipeColors.water);
            graphics.strokeCircle(32, 32, 24);
            graphics.generateTexture('pipe_source', 64, 64);
            graphics.clear();

            // Sink
            graphics.fillStyle(pipeColors.sink);
            graphics.fillCircle(32, 32, 24);
            graphics.lineStyle(3, pipeColors.water);
            graphics.strokeCircle(32, 32, 24);
            graphics.generateTexture('pipe_sink', 64, 64);
            graphics.clear();

            // Water particle
            graphics.fillStyle(pipeColors.water);
            graphics.fillCircle(4, 4, 4);
            graphics.generateTexture('water', 8, 8);
            graphics.clear();
        }

        function create() {
            const width = this.scale.width;
            const height = this.scale.height;

            // Background
            const bg = this.add.graphics();
            bg.fillGradientStyle(0x0a0a0f, 0x0a0a0f, 0x0a1a2a, 0x0a1a2a, 1);
            bg.fillRect(0, 0, width, height);

            // Grid container
            gridGroup = this.add.group();
            
            // Timer display
            timerText = this.add.text(width / 2, 30, '', {
                fontFamily: 'Cinzel',
                fontSize: '24px',
                color: '#4fc3f7'
            }).setOrigin(0.5);

            // Story text
            storyText = this.add.text(width / 2, height - 100, '', {
                fontFamily: 'Inter',
                fontSize: '16px',
                color: '#a0a0b0',
                align: 'center',
                wordWrap: { width: width - 40 }
            }).setOrigin(0.5);

            // Water particles
            waterParticles = this.add.particles(0, 0, 'water', {
                speed: { min: 50, max: 100 },
                scale: { start: 0.5, end: 0 },
                blendMode: 'ADD',
                lifespan: 1000,
                quantity: 2,
                frequency: 100
            });
            waterParticles.stop();

            // Generate level
            generateLevel(this);

            // Resize handler
            this.scale.on('resize', (gameSize) => {
                const newWidth = gameSize.width;
                const newHeight = gameSize.height;
                timerText.setPosition(newWidth / 2, 30);
                storyText.setPosition(newWidth / 2, newHeight - 100);
                storyText.setWordWrapWidth(newWidth - 40);
                renderGrid(this, newWidth, newHeight);
            });
        }

        function update(time, delta) {
            if (GameState.mode === 'time' && GameState.waterFlowing && !GameState.levelCompleted) {
                GameState.timer -= delta / 1000;
                if (GameState.timer <= 0) {
                    GameState.timer = 0;
                    levelFailed();
                }
                timerText.setText(`‚è±Ô∏è ${Math.ceil(GameState.timer)}s`);
            } else if (GameState.mode === 'normal') {
                timerText.setText(`üß© ${GameState.moves} moves`);
            }
        }

        function generateLevel(scene) {
            GameState.tiles = [];
            GameState.waterFlowing = false;
            GameState.levelCompleted = false;
            GameState.moves = 0;
            
            if (GameState.mode === 'time') {
                GameState.timer = Math.max(30, 90 - (GameState.currentLevel * 2));
                GameState.timeLimit = GameState.timer;
            }

            const size = Math.min(6 + Math.floor(GameState.currentLevel / 5), 10);
            GameState.gridSize = size;

            // Initialize empty grid
            for (let y = 0; y < size; y++) {
                GameState.tiles[y] = [];
                for (let x = 0; x < size; x++) {
                    GameState.tiles[y][x] = {
                        type: PIPE_TYPES.EMPTY,
                        rotation: 0,
                        hasWater: false,
                        x: x,
                        y: y
                    };
                }
            }

            // Place source and sink
            const sourceX = 0;
            const sourceY = Math.floor(size / 2);
            const sinkX = size - 1;
            const sinkY = Math.floor(size / 2);

            GameState.tiles[sourceY][sourceX].type = PIPE_TYPES.SOURCE;
            GameState.tiles[sinkY][sinkX].type = PIPE_TYPES.SINK;

            // Generate solution path
            generatePath(sourceX, sourceY, sinkX, sinkY, size);

            // Add random pipes
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (GameState.tiles[y][x].type === PIPE_TYPES.EMPTY) {
                        if (Math.random() < 0.6) {
                            const types = [PIPE_TYPES.STRAIGHT, PIPE_TYPES.CORNER, PIPE_TYPES.TJUNCTION, PIPE_TYPES.CROSS];
                            GameState.tiles[y][x].type = types[Math.floor(Math.random() * types.length)];
                            GameState.tiles[y][x].rotation = Math.floor(Math.random() * 4);
                        }
                    } else if (GameState.tiles[y][x].type !== PIPE_TYPES.SOURCE && GameState.tiles[y][x].type !== PIPE_TYPES.SINK) {
                        GameState.tiles[y][x].rotation = Math.floor(Math.random() * 4);
                    }
                }
            }

            renderGrid(scene, scene.scale.width, scene.scale.height);
        }

        function generatePath(sx, sy, ex, ey, size) {
            let cx = sx;
            let cy = sy;
            
            while (cx !== ex || cy !== ey) {
                const dx = ex - cx;
                const dy = ey - cy;
                
                let nx = cx;
                let ny = cy;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    nx += dx > 0 ? 1 : -1;
                } else {
                    ny += dy > 0 ? 1 : -1;
                }
                
                if (nx >= 0 && nx < size && ny >= 0 && ny < size) {
                    if (GameState.tiles[ny][nx].type === PIPE_TYPES.EMPTY) {
                        const types = [PIPE_TYPES.STRAIGHT, PIPE_TYPES.CORNER, PIPE_TYPES.TJUNCTION];
                        GameState.tiles[ny][nx].type = types[Math.floor(Math.random() * types.length)];
                        GameState.tiles[ny][nx].rotation = 0;
                    }
                    cx = nx;
                    cy = ny;
                } else {
                    break;
                }
            }
        }

        function renderGrid(scene, width, height) {
            gridGroup.clear(true, true);
            
            const size = GameState.gridSize;
            const tileSize = Math.min((width - 40) / size, (height - 200) / size, 64);
            const startX = (width - (size * tileSize)) / 2;
            const startY = (height - (size * tileSize)) / 2 - 20;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const tile = GameState.tiles[y][x];
                    const posX = startX + x * tileSize + tileSize / 2;
                    const posY = startY + y * tileSize + tileSize / 2;

                    let texture = 'tile_empty';
                    let tint = 0xffffff;

                    switch(tile.type) {
                        case PIPE_TYPES.STRAIGHT: texture = 'pipe_straight'; break;
                        case PIPE_TYPES.CORNER: texture = 'pipe_corner'; break;
                        case PIPE_TYPES.TJUNCTION: texture = 'pipe_t'; break;
                        case PIPE_TYPES.CROSS: texture = 'pipe_cross'; break;
                        case PIPE_TYPES.SOURCE: texture = 'pipe_source'; break;
                        case PIPE_TYPES.SINK: texture = 'pipe_sink'; break;
                    }

                    const sprite = scene.add.sprite(posX, posY, texture);
                    sprite.setScale(tileSize / 64);
                    sprite.setRotation(tile.rotation * Math.PI / 2);
                    sprite.setInteractive({ useHandCursor: true });
                    sprite.setData('x', x);
                    sprite.setData('y', y);

                    if (tile.hasWater) {
                        tint = 0x80d8ff;
                        waterParticles.emitParticleAt(posX, posY, 1);
                    }
                    
                    sprite.setTint(tint);

                    sprite.on('pointerdown', () => {
                        rotateTile(x, y, scene);
                    });

                    gridGroup.add(sprite);
                }
            }
        }

        function rotateTile(x, y, scene) {
            if (GameState.levelCompleted) return;
            
            const tile = GameState.tiles[y][x];
            if (tile.type === PIPE_TYPES.SOURCE || tile.type === PIPE_TYPES.SINK || tile.type === PIPE_TYPES.EMPTY) {
                return;
            }

            tile.rotation = (tile.rotation + 1) % 4;
            GameState.moves++;
            
            // Play rotation sound effect (placeholder)
            
            renderGrid(scene, scene.scale.width, scene.scale.height);
            
            // Check flow
            setTimeout(() => checkWaterFlow(scene), 100);
        }

        function checkWaterFlow(scene) {
            // Reset water state
            for (let y = 0; y < GameState.gridSize; y++) {
                for (let x = 0; x < GameState.gridSize; x++) {
                    GameState.tiles[y][x].hasWater = false;
                }
            }

            // Find source
            let sourceX = -1, sourceY = -1;
            for (let y = 0; y < GameState.gridSize; y++) {
                for (let x = 0; x < GameState.gridSize; x++) {
                    if (GameState.tiles[y][x].type === PIPE_TYPES.SOURCE) {
                        sourceX = x;
                        sourceY = y;
                        break;
                    }
                }
                if (sourceX !== -1) break;
            }

            if (sourceX === -1) return;

            // BFS to propagate water
            const queue = [{x: sourceX, y: sourceY}];
            GameState.tiles[sourceY][sourceX].hasWater = true;
            
            const directions = [
                {dx: 0, dy: -1, from: 0, to: 2}, // Up
                {dx: 1, dy: 0, from: 1, to: 3},  // Right
                {dx: 0, dy: 1, from: 2, to: 0},  // Down
                {dx: -1, dy: 0, from: 3, to: 1}  // Left
            ];

            let sinkReached = false;

            while (queue.length > 0) {
                const current = queue.shift();
                const tile = GameState.tiles[current.y][current.x];

                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;

                    if (nx >= 0 && nx < GameState.gridSize && ny >= 0 && ny < GameState.gridSize) {
                        const neighbor = GameState.tiles[ny][nx];
                        
                        if (!neighbor.hasWater && canConnect(tile, neighbor, dir.from, dir.to)) {
                            neighbor.hasWater = true;
                            queue.push({x: nx, y: ny});
                            
                            if (neighbor.type === PIPE_TYPES.SINK) {
                                sinkReached = true;
                            }
                        }
                    }
                }
            }

            GameState.waterFlowing = true;
            renderGrid(scene, scene.scale.width, scene.scale.height);

            if (sinkReached && !GameState.levelCompleted) {
                GameState.levelCompleted = true;
                levelComplete();
            }
        }

        function canConnect(from, to, fromDir, toDir) {
            // Check if 'from' pipe has opening in fromDir direction
            // Check if 'to' pipe has opening in toDir direction
            const fromOpenings = getOpenings(from.type, from.rotation);
            const toOpenings = getOpenings(to.type, to.rotation);
            
            return fromOpenings.includes(fromDir) && toOpenings.includes(toDir);
        }

        function getOpenings(type, rotation) {
            const openings = {
                [PIPE_TYPES.EMPTY]: [],
                [PIPE_TYPES.STRAIGHT]: [0, 2],
                [PIPE_TYPES.CORNER]: [0, 1],
                [PIPE_TYPES.TJUNCTION]: [0, 1, 2],
                [PIPE_TYPES.CROSS]: [0, 1, 2, 3],
                [PIPE_TYPES.SOURCE]: [1], // Source flows right
                [PIPE_TYPES.SINK]: [3]    // Sink receives from left
            };
            
            const base = openings[type] || [];
            return base.map(o => (o + rotation) % 4);
        }

        function levelComplete() {
            const baseXP = 50;
            const timeBonus = GameState.mode === 'time' ? Math.floor(GameState.timer) : 0;
            const moveBonus = Math.max(0, 20 - GameState.moves);
            const totalXP = baseXP + timeBonus + moveBonus;
            
            GameState.xp += totalXP;
            
            // Unlock next level
            if (GameState.currentLevel >= GameState.maxUnlocked) {
                GameState.maxUnlocked = GameState.currentLevel + 1;
            }
            
            // Show story fragment
            const storyIndex = (GameState.currentLevel - 1) % GameState.stories.length;
            const story = GameState.stories[storyIndex];
            
            document.getElementById('successMessage').textContent = story;
            document.getElementById('xpReward').textContent = `+${totalXP} XP`;
            document.getElementById('modalOverlay').classList.add('active');
            document.getElementById('successModal').classList.add('active');
            
            // Agent message
            showAgentMessage('River-Storyteller', 'The Flowing Narrator', 'üåä',
                `Level ${GameState.currentLevel} complete! ${story} The river reveals its secrets to those who listen.`);
            
            saveProgress();
            updateXPDisplay();
            initLevelSelector();
            
            syncWithArcanea(totalXP, 'level_complete');
        }

        function levelFailed() {
            showAgentMessage('River-Storyteller', 'The Flowing Narrator', 'üåä',
                'Time has run out. The waters remain disconnected. Try again - patience is the key to mastering the flow.');
            
            // Reset level
            const scene = game.scene.scenes[0];
            generateLevel(scene);
        }

        function nextLevel() {
            document.getElementById('modalOverlay').classList.remove('active');
            document.getElementById('successModal').classList.remove('active');
            
            GameState.currentLevel++;
            const scene = game.scene.scenes[0];
            generateLevel(scene);
            updateLevelDisplay();
        }

        function setMode(mode) {
            GameState.mode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode + 'Mode').classList.add('active');
            
            const scene = game.scene.scenes[0];
            generateLevel(scene);
            
            showAgentMessage('River-Storyteller', 'The Flowing Narrator', 'üåä',
                `Switched to ${mode} mode. ${mode === 'zen' ? 'Take your time and enjoy the flow.' : mode === 'time' ? 'Race against the clock!' : 'Standard puzzle solving.'}`);
        }

        function initLevelSelector() {
            const grid = document.getElementById('levelGrid');
            grid.innerHTML = '';
            
            for (let i = 1; i <= 50; i++) {
                const btn = document.createElement('button');
                btn.className = 'level-btn';
                btn.textContent = i;
                
                if (i <= GameState.maxUnlocked) {
                    if (i < GameState.currentLevel) {
                        btn.classList.add('completed');
                    }
                    btn.onclick = () => loadLevel(i);
                } else {
                    btn.classList.add('locked');
                }
                
                grid.appendChild(btn);
            }
        }

        function loadLevel(level) {
            GameState.currentLevel = level;
            updateLevelDisplay();
            toggleLevelSelector();
            const scene = game.scene.scenes[0];
            generateLevel(scene);
        }

        function toggleLevelSelector() {
            document.getElementById('levelSelector').classList.toggle('active');
        }

        function updateXPDisplay() {
            document.getElementById('xpDisplay').textContent = GameState.xp.toLocaleString();
        }

        function updateLevelDisplay() {
            document.getElementById('levelDisplay').textContent = GameState.currentLevel;
        }

        function showAgentMessage(name, role, avatar, message) {
            document.getElementById('agentName').textContent = name;
            document.getElementById('agentRole').textContent = role;
            document.getElementById('agentAvatar').textContent = avatar;
            document.getElementById('agentMessage').textContent = message;
            document.getElementById('agentPanel').classList.add('active');
            
            setTimeout(() => {
                closeAgentPanel();
            }, 8000);
        }

        function closeAgentPanel() {
            document.getElementById('agentPanel').classList.remove('active');
        }

        function goBack() {
            window.location.href = '../games-v2.html';
        }

        function saveProgress() {
            const data = {
                xp: GameState.xp,
                maxUnlocked: GameState.maxUnlocked,
                currentLevel: GameState.currentLevel
            };
            localStorage.setItem('riverFlowData', JSON.stringify(data));
        }

        function loadProgress() {
            const saved = localStorage.getItem('riverFlowData');
            if (saved) {
                const data = JSON.parse(saved);
                GameState.xp = data.xp || 0;
                GameState.maxUnlocked = data.maxUnlocked || 1;
                GameState.currentLevel = data.currentLevel || 1;
                updateXPDisplay();
                updateLevelDisplay();
            }
        }

        function syncWithArcanea(xp, reason) {
            if (window.Arcanea && window.Arcanea.awardXP) {
                window.Arcanea.awardXP({
                    gameId: 'river-flow',
                    amount: xp,
                    reason: reason,
                    agent: '@river-storyteller'
                });
            }
            
            window.dispatchEvent(new CustomEvent('riverFlowProgress', {
                detail: { xp, level: GameState.currentLevel, timestamp: Date.now() }
            }));
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeAgentPanel();
                document.getElementById('levelSelector').classList.remove('active');
                document.getElementById('modalOverlay').classList.remove('active');
                document.getElementById('successModal').classList.remove('active');
            }
        });

        // Prevent double-tap zoom
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    </script>
</body>
</html>
