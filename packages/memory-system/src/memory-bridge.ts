/**
 * Memory Bridge — Syncs Starlight Vaults → MEMORY.md
 *
 * Creates a structured MEMORY.md that Claude Code can read natively,
 * synthesized from the 6 Starlight Vaults with intelligent prioritization.
 *
 * The output respects Claude Code's 200-line limit by prioritizing:
 * 1. High/verified confidence entries
 * 2. Recently accessed entries
 * 3. Entries with most tags
 * 4. Strategic vault gets most space (decisions matter most)
 *
 * Storage layout expected:
 *   {vaultStoragePath}/
 *     vaults/
 *       {vault-type}/
 *         index.json       ← per-vault entry index
 *         {id}.md          ← full entry content
 *     horizon/
 *       entries.jsonl      ← append-only Horizon Ledger
 */

import {
  writeFileSync,
  readFileSync,
  existsSync,
  mkdirSync,
  watch,
} from 'node:fs';
import { join, dirname } from 'node:path';
import type { VaultType, ConfidenceLevel, GuardianName } from './types.js';
import { CONFIDENCE_RANK } from './types.js';

// ── Budget constants ──────────────────────────────────────────────────────────

/** How many lines each vault section may occupy in MEMORY.md */
const VAULT_LINE_BUDGETS: Record<VaultType, number> = {
  strategic:   40,  // Decisions, architecture — highest priority
  technical:   35,  // Patterns, solutions — frequently referenced
  wisdom:      30,  // Meta-patterns — high long-term value
  creative:    25,  // Voice, brand — stable, changes slowly
  operational: 20,  // Session state — short-lived
  horizon:     15,  // Wishes — brief mention only
} as const;

/** Display order in the generated MEMORY.md */
const VAULT_ORDER: VaultType[] = [
  'strategic',
  'technical',
  'wisdom',
  'creative',
  'operational',
  'horizon',
];

/** Section headers per vault */
const VAULT_SECTION_HEADERS: Record<VaultType, string> = {
  strategic:   '## Strategic Vault (Decisions & Architecture)',
  technical:   '## Technical Vault (Patterns & Solutions)',
  wisdom:      '## Wisdom Vault (Meta-Patterns)',
  creative:    '## Creative Vault (Voice & Brand)',
  operational: '## Operational Vault (Session Context)',
  horizon:     '## Horizon Vault (Benevolent Intentions)',
} as const;

// ── Internal index shape (matches FileBackend VaultIndex) ─────────────────────

interface VaultIndexEntry {
  id: string;
  vault: VaultType;
  createdAt: string;
  tags: string[];
  summary: string;
}

interface HorizonJsonlEntry {
  id?: string;
  wish: string;
  context?: string;
  author?: string;
  createdAt?: string;
}

// ── Public API ────────────────────────────────────────────────────────────────

export interface BridgeConfig {
  /** Where to write MEMORY.md. Default: `{cwd}/.arcanea/memory/MEMORY.md` */
  outputPath?: string;
  /** Hard line limit respecting Claude Code's 200-line cap. Default: 190 */
  maxLines?: number;
  /** Root path that contains `vaults/` and `horizon/`. Default: `{cwd}/.arcanea/memory` */
  vaultStoragePath?: string;
  /** Watch vault directories and auto-sync on changes. Default: false */
  autoWatch?: boolean;
  /** Include Horizon Vault entries in MEMORY.md. Default: true */
  includeHorizon?: boolean;
  /** First line of the generated MEMORY.md */
  sessionHeader?: string;
}

export interface SyncResult {
  linesWritten: number;
  entriesIncluded: number;
  vaultCounts: Partial<Record<VaultType, number>>;
  outputPath: string;
  timestamp: string;
}

// ── MemoryBridge ──────────────────────────────────────────────────────────────

export class MemoryBridge {
  private readonly cfg: Required<BridgeConfig>;
  private watcher?: ReturnType<typeof watch>;

  constructor(config?: BridgeConfig) {
    const cwd = process.cwd();
    const storagePath = config?.vaultStoragePath ?? join(cwd, '.arcanea', 'memory');
    this.cfg = {
      outputPath:       config?.outputPath   ?? join(storagePath, 'MEMORY.md'),
      maxLines:         config?.maxLines      ?? 190,
      vaultStoragePath: storagePath,
      autoWatch:        config?.autoWatch     ?? false,
      includeHorizon:   config?.includeHorizon ?? true,
      sessionHeader:    config?.sessionHeader  ?? '# Arcanea Memory — Starlight Vaults',
    };
  }

  // ── Public Methods ──────────────────────────────────────────────────────────

  /**
   * Reads all vaults, synthesizes a prioritized MEMORY.md, and writes it to
   * `outputPath`. Returns metadata about what was written.
   */
  sync(): SyncResult {
    const sections: string[] = [];
    const vaultCounts: Partial<Record<VaultType, number>> = {};
    let totalEntries = 0;

    // Document header
    sections.push(this.cfg.sessionHeader);
    sections.push(`*Synced: ${new Date().toISOString()}*`);
    sections.push('');
    sections.push('> Auto-generated by Starlight Vaults. Edit the source vaults, not this file.');
    sections.push('');

    const vaultsToRender = this.cfg.includeHorizon
      ? VAULT_ORDER
      : VAULT_ORDER.filter((v) => v !== 'horizon');

    for (const vault of vaultsToRender) {
      if (vault === 'horizon') {
        // Horizon has a separate JSONL source — render separately
        const horizonLines = this.renderHorizon(5);
        if (horizonLines.length > 0) {
          sections.push(...horizonLines);
          sections.push('');
        }
        continue;
      }

      const entries = this.loadVaultIndex(vault);
      if (entries.length === 0) continue;

      const prioritized = this.prioritize(entries);
      const budget = VAULT_LINE_BUDGETS[vault];
      const sectionLines = this.renderSection(vault, prioritized, budget);

      sections.push(...sectionLines);
      sections.push('');

      vaultCounts[vault] = prioritized.length;
      totalEntries += prioritized.length;
    }

    const content = sections.join('\n');
    const lines = content.split('\n');
    const truncated = lines.slice(0, this.cfg.maxLines).join('\n');

    // Ensure output directory exists
    const outputDir = dirname(this.cfg.outputPath);
    if (!existsSync(outputDir)) {
      mkdirSync(outputDir, { recursive: true });
    }

    writeFileSync(this.cfg.outputPath, truncated, 'utf-8');

    return {
      linesWritten: truncated.split('\n').length,
      entriesIncluded: totalEntries,
      vaultCounts,
      outputPath: this.cfg.outputPath,
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * Appends a raw block to MEMORY.md without a full vault sync.
   * Useful for quick in-session additions. Falls back to full sync if near the
   * line limit.
   */
  appendToMemory(content: string, heading?: string): void {
    if (!existsSync(this.cfg.outputPath)) {
      this.sync();
      return;
    }

    const addition = heading
      ? `\n## ${heading}\n${content}\n`
      : `\n${content}\n`;

    const current = readFileSync(this.cfg.outputPath, 'utf-8');
    const lineCount = current.split('\n').length;

    if (lineCount < this.cfg.maxLines - 10) {
      writeFileSync(this.cfg.outputPath, current + addition, 'utf-8');
    } else {
      // At capacity — full sync to keep the file clean
      this.sync();
    }
  }

  /**
   * Start watching vault directories for file-system changes, debouncing
   * re-syncs to 500 ms.
   */
  startWatching(): void {
    const watchDir = join(this.cfg.vaultStoragePath, 'vaults');
    if (!existsSync(watchDir)) return;

    let debounce: ReturnType<typeof setTimeout>;
    this.watcher = watch(watchDir, { recursive: true }, () => {
      clearTimeout(debounce);
      debounce = setTimeout(() => {
        try {
          this.sync();
        } catch (err) {
          // Non-fatal — log but do not crash the watcher
          console.error('[MemoryBridge] Auto-sync failed:', err);
        }
      }, 500);
    });
  }

  /** Stop the file-system watcher if one is active. */
  stopWatching(): void {
    this.watcher?.close();
    this.watcher = undefined;
  }

  // ── Private Helpers ─────────────────────────────────────────────────────────

  /**
   * Load the vault index file for a given vault type.
   * Returns an empty array if the index does not exist yet.
   */
  private loadVaultIndex(vault: VaultType): VaultIndexEntry[] {
    const indexPath = join(this.cfg.vaultStoragePath, 'vaults', vault, 'index.json');
    if (!existsSync(indexPath)) return [];

    try {
      const raw = readFileSync(indexPath, 'utf-8');
      const parsed = JSON.parse(raw) as { entries?: VaultIndexEntry[] };
      return Array.isArray(parsed.entries) ? parsed.entries : [];
    } catch {
      return [];
    }
  }

  /**
   * Sort entries by priority score descending, take top 20 candidates.
   * Priority = confidence rank (3x weight) + tag count + recency bonus.
   */
  private prioritize(entries: VaultIndexEntry[]): VaultIndexEntry[] {
    const now = Date.now();

    const scored = entries.map((e) => {
      const confidenceScore =
        CONFIDENCE_RANK[e.vault as unknown as ConfidenceLevel] ?? 0;
      const tagScore = (e.tags?.length ?? 0);
      const ageMs = now - new Date(e.createdAt ?? 0).getTime();
      // Recency bonus: full point within 24 h, decays linearly over 7 days
      const recency = Math.max(0, 1 - ageMs / (7 * 24 * 60 * 60 * 1000));

      return {
        entry: e,
        score: confidenceScore * 3 + tagScore + recency,
      };
    });

    return scored
      .sort((a, b) => b.score - a.score)
      .slice(0, 20)
      .map((s) => s.entry);
  }

  /**
   * Render a single vault section as an array of markdown lines, respecting
   * the per-vault line budget.
   */
  private renderSection(
    vault: VaultType,
    entries: VaultIndexEntry[],
    lineBudget: number,
  ): string[] {
    const header = VAULT_SECTION_HEADERS[vault];
    const lines: string[] = [header];
    let usedLines = 1;

    for (const entry of entries) {
      if (usedLines >= lineBudget) break;

      const date = entry.createdAt?.slice(0, 10) ?? 'unknown';
      const tags = entry.tags?.slice(0, 3).join(', ') ?? '';
      const tagsStr = tags ? ` [${tags}]` : '';

      // Prefer the index summary (short); truncate to ~100 chars for readability
      const text = (entry.summary ?? '').replace(/\n/g, ' ').trim();
      const preview = text.length > 100 ? text.slice(0, 100) + '...' : text;

      lines.push(`- **${date}**${tagsStr}: ${preview}`);
      usedLines++;
    }

    return lines;
  }

  /**
   * Render the Horizon Vault section from its append-only JSONL ledger.
   * Reads the last `limit` entries (most recent wishes).
   */
  private renderHorizon(limit: number): string[] {
    const horizonPath = join(
      this.cfg.vaultStoragePath,
      'horizon',
      'entries.jsonl',
    );
    if (!existsSync(horizonPath)) return [];

    try {
      const raw = readFileSync(horizonPath, 'utf-8');
      const lines = raw
        .trim()
        .split('\n')
        .filter(Boolean);

      if (lines.length === 0) return [];

      // Take the most recent `limit` entries
      const recent = lines
        .slice(-limit)
        .reverse()
        .map((l) => JSON.parse(l) as HorizonJsonlEntry);

      const output: string[] = [VAULT_SECTION_HEADERS['horizon']];
      for (const entry of recent) {
        const wish = (entry.wish ?? '').slice(0, 80);
        const ellipsis = (entry.wish?.length ?? 0) > 80 ? '...' : '';
        output.push(`- *"${wish}${ellipsis}"*`);
      }
      return output;
    } catch {
      return [];
    }
  }
}

// ── Convenience Functions ─────────────────────────────────────────────────────

/**
 * Create a MemoryBridge and perform a single sync in one call.
 *
 * @example
 * ```typescript
 * import { syncMemory } from '@arcanea/memory-system';
 *
 * const result = await syncMemory({ outputPath: '.arcanea/memory/MEMORY.md' });
 * console.log(`Wrote ${result.linesWritten} lines`);
 * ```
 */
export function syncMemory(config?: BridgeConfig): SyncResult {
  return new MemoryBridge(config).sync();
}

/**
 * Append a note to MEMORY.md without a full vault sync.
 *
 * @example
 * ```typescript
 * import { appendMemoryNote } from '@arcanea/memory-system';
 *
 * appendMemoryNote('Decided to use pnpm workspaces', 'Architecture Note');
 * ```
 */
export function appendMemoryNote(
  content: string,
  heading?: string,
  config?: BridgeConfig,
): void {
  new MemoryBridge(config).appendToMemory(content, heading);
}
