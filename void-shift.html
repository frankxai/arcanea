<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Void Shift - Arcanea Games</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
            mono: ['JetBrains Mono', 'monospace'],
          },
        },
      },
    }
  </script>
  <style>
    * {
      font-family: 'Inter', system-ui, sans-serif;
      user-select: none;
    }
    .font-mono { font-family: 'JetBrains Mono', monospace; }

    html, body {
      overscroll-behavior: none;
    }

    /* Dimension shift animation */
    @keyframes dimensionShift {
      0% { transform: scale(1); filter: hue-rotate(0deg); }
      50% { transform: scale(1.02); filter: hue-rotate(180deg); }
      100% { transform: scale(1); filter: hue-rotate(360deg); }
    }
    .shifting { animation: dimensionShift 0.5s ease-in-out; }

    /* Tile animations */
    @keyframes tileAppear {
      0% { transform: scale(0) rotate(-180deg); opacity: 0; }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }
    .tile-appear { animation: tileAppear 0.3s ease-out forwards; }

    /* Glow effects */
    .glow-void { box-shadow: 0 0 30px rgba(168, 85, 247, 0.4); }
    .glow-light { box-shadow: 0 0 30px rgba(251, 191, 36, 0.4); }

    /* Win animation */
    @keyframes celebrate {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    .celebrate { animation: celebrate 0.5s ease-in-out 3; }
  </style>
</head>
<body class="bg-slate-950 min-h-screen">
  <!-- Background -->
  <div class="fixed inset-0 bg-gradient-to-br from-slate-950 via-purple-950/20 to-slate-950 pointer-events-none"></div>
  <div class="fixed inset-0 bg-[radial-gradient(ellipse_at_center,_var(--tw-gradient-stops))] from-purple-900/10 via-transparent to-transparent pointer-events-none"></div>

  <div class="relative z-10 min-h-screen flex flex-col">
    <!-- Header -->
    <header class="border-b border-slate-800/50 p-4">
      <div class="max-w-4xl mx-auto flex items-center justify-between">
        <div class="flex items-center gap-3">
          <button onclick="window.location.href='games-portal.html'" class="w-10 h-10 rounded-xl bg-slate-900 border border-slate-700/50 flex items-center justify-center hover:bg-slate-800 transition-colors">
            <svg class="w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
            </svg>
          </button>
          <div>
            <h1 class="text-lg font-semibold text-white">Void Shift</h1>
            <p class="text-xs text-slate-500">Level <span id="levelDisplay" class="font-mono text-purple-400">1</span></p>
          </div>
        </div>

        <div class="flex items-center gap-4">
          <!-- Moves -->
          <div class="text-center">
            <p class="text-xs text-slate-500">Moves</p>
            <p id="movesDisplay" class="text-lg font-semibold text-white font-mono">0</p>
          </div>
          <!-- Dimension Indicator -->
          <div id="dimensionIndicator" class="px-4 py-2 rounded-xl bg-purple-500/20 border border-purple-500/30">
            <p class="text-xs text-purple-400 uppercase tracking-wider">Dimension</p>
            <p id="dimensionDisplay" class="text-lg font-bold text-purple-400 font-mono">VOID</p>
          </div>
        </div>
      </div>
    </header>

    <!-- Main Game Area -->
    <main class="flex-1 flex flex-col items-center justify-center p-4">
      <!-- Game Grid -->
      <div id="gameContainer" class="relative">
        <div id="gameGrid" class="grid gap-2 p-4 bg-slate-900/50 rounded-2xl border border-slate-700/50">
          <!-- Grid will be generated by JS -->
        </div>

        <!-- Shift indicator overlay -->
        <div id="shiftOverlay" class="absolute inset-0 pointer-events-none opacity-0 transition-opacity duration-300">
          <div class="w-full h-full bg-purple-500/10 rounded-2xl"></div>
        </div>
      </div>

      <!-- Controls -->
      <div class="mt-6 flex gap-3">
        <button id="shiftBtn" class="px-6 py-3 bg-gradient-to-r from-purple-600 to-violet-600 hover:from-purple-500 hover:to-violet-500 text-white font-semibold rounded-xl transition-all flex items-center gap-2">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
          </svg>
          Shift Dimension
        </button>
        <button id="resetBtn" class="px-4 py-3 bg-slate-800 hover:bg-slate-700 text-slate-300 font-medium rounded-xl border border-slate-700 transition-colors">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
          </svg>
        </button>
      </div>

      <!-- Level info -->
      <div class="mt-4 text-center">
        <p class="text-sm text-slate-500">Move the <span class="text-purple-400">orb</span> to the <span class="text-amber-400">goal</span></p>
        <p class="text-xs text-slate-600 mt-1">Some paths only exist in certain dimensions</p>
      </div>
    </main>

    <!-- Level Complete Modal -->
    <div id="levelCompleteModal" class="fixed inset-0 bg-slate-950/90 backdrop-blur-sm flex items-center justify-center p-4 hidden z-50">
      <div class="bg-slate-900 rounded-2xl border border-slate-700/50 p-8 max-w-sm w-full text-center">
        <div class="w-16 h-16 rounded-2xl bg-gradient-to-br from-purple-500 to-violet-600 flex items-center justify-center mx-auto mb-4 celebrate">
          <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
          </svg>
        </div>
        <h2 class="text-2xl font-bold text-white mb-2">Level Complete!</h2>
        <p class="text-slate-400 mb-6">You solved it in <span id="completeMoves" class="text-purple-400 font-mono">0</span> moves</p>

        <div class="flex gap-3">
          <button id="nextLevelBtn" class="flex-1 py-3 bg-gradient-to-r from-purple-600 to-violet-600 text-white font-semibold rounded-xl">
            Next Level
          </button>
          <button onclick="window.location.href='games-portal.html'" class="px-4 py-3 bg-slate-800 text-slate-300 rounded-xl border border-slate-700">
            Exit
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Game State
    const game = {
      level: 1,
      moves: 0,
      dimension: 'void', // 'void' or 'light'
      gridSize: 5,
      grid: [],
      playerPos: { x: 0, y: 0 },
      goalPos: { x: 4, y: 4 },
      levels: []
    };

    // Tile types
    const TILE = {
      EMPTY: 0,
      WALL: 1,
      VOID_ONLY: 2,    // Only passable in void dimension
      LIGHT_ONLY: 3,   // Only passable in light dimension
      PLAYER: 4,
      GOAL: 5,
      VOID_WALL: 6,    // Wall only in void dimension
      LIGHT_WALL: 7    // Wall only in light dimension
    };

    // Level definitions
    const LEVELS = [
      // Level 1 - Tutorial
      {
        size: 5,
        start: { x: 0, y: 2 },
        goal: { x: 4, y: 2 },
        grid: [
          [0, 0, 0, 0, 0],
          [1, 1, 2, 1, 1],
          [0, 0, 0, 0, 0],
          [1, 1, 3, 1, 1],
          [0, 0, 0, 0, 0]
        ]
      },
      // Level 2
      {
        size: 5,
        start: { x: 0, y: 0 },
        goal: { x: 4, y: 4 },
        grid: [
          [0, 0, 1, 0, 0],
          [0, 1, 2, 0, 1],
          [1, 0, 0, 0, 0],
          [0, 0, 1, 3, 0],
          [0, 1, 0, 0, 0]
        ]
      },
      // Level 3
      {
        size: 6,
        start: { x: 0, y: 0 },
        goal: { x: 5, y: 5 },
        grid: [
          [0, 0, 1, 0, 2, 0],
          [1, 0, 1, 0, 1, 0],
          [0, 0, 0, 0, 0, 0],
          [0, 1, 1, 3, 1, 0],
          [0, 0, 0, 0, 0, 1],
          [1, 2, 0, 1, 0, 0]
        ]
      },
      // Level 4
      {
        size: 6,
        start: { x: 0, y: 2 },
        goal: { x: 5, y: 3 },
        grid: [
          [1, 0, 0, 0, 6, 0],
          [0, 6, 1, 0, 0, 0],
          [0, 0, 0, 7, 0, 1],
          [1, 0, 7, 0, 0, 0],
          [0, 0, 0, 1, 6, 0],
          [0, 6, 0, 0, 0, 1]
        ]
      },
      // Level 5
      {
        size: 7,
        start: { x: 0, y: 3 },
        goal: { x: 6, y: 3 },
        grid: [
          [1, 0, 0, 2, 0, 0, 1],
          [0, 1, 0, 1, 0, 1, 0],
          [0, 0, 0, 0, 0, 0, 0],
          [0, 0, 1, 0, 1, 0, 0],
          [0, 0, 0, 0, 0, 0, 0],
          [0, 1, 0, 1, 0, 1, 0],
          [1, 0, 0, 3, 0, 0, 1]
        ]
      }
    ];

    // Initialize
    function init() {
      document.getElementById('shiftBtn').addEventListener('click', shiftDimension);
      document.getElementById('resetBtn').addEventListener('click', resetLevel);
      document.getElementById('nextLevelBtn').addEventListener('click', nextLevel);

      // Keyboard controls
      document.addEventListener('keydown', handleKeyDown);

      loadLevel(1);
    }

    function loadLevel(levelNum) {
      game.level = levelNum;
      game.moves = 0;
      game.dimension = 'void';

      const levelData = LEVELS[Math.min(levelNum - 1, LEVELS.length - 1)];
      game.gridSize = levelData.size;
      game.grid = JSON.parse(JSON.stringify(levelData.grid)); // Deep copy
      game.playerPos = { ...levelData.start };
      game.goalPos = { ...levelData.goal };

      updateUI();
      renderGrid();
    }

    function renderGrid() {
      const container = document.getElementById('gameGrid');
      container.innerHTML = '';

      // Set grid size
      const tileSize = Math.min(60, (window.innerWidth - 64) / game.gridSize);
      container.style.gridTemplateColumns = `repeat(${game.gridSize}, ${tileSize}px)`;
      container.style.gridTemplateRows = `repeat(${game.gridSize}, ${tileSize}px)`;

      for (let y = 0; y < game.gridSize; y++) {
        for (let x = 0; x < game.gridSize; x++) {
          const tile = document.createElement('div');
          tile.className = 'rounded-lg transition-all duration-200 flex items-center justify-center tile-appear';
          tile.style.animationDelay = `${(x + y) * 30}ms`;
          tile.dataset.x = x;
          tile.dataset.y = y;

          // Click handler for movement
          tile.addEventListener('click', () => tryMove(x, y));

          const tileType = game.grid[y][x];
          const isPassable = isTilePassable(x, y);

          // Tile styling based on type and dimension
          if (x === game.playerPos.x && y === game.playerPos.y) {
            // Player
            tile.className += ' bg-gradient-to-br from-purple-500 to-violet-600 glow-void';
            tile.innerHTML = `
              <div class="w-6 h-6 rounded-full bg-white/30 backdrop-blur-sm"></div>
            `;
          } else if (x === game.goalPos.x && y === game.goalPos.y) {
            // Goal
            tile.className += ' bg-gradient-to-br from-amber-500 to-orange-500 glow-light';
            tile.innerHTML = `
              <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z"/>
              </svg>
            `;
          } else if (tileType === TILE.WALL) {
            // Permanent wall
            tile.className += ' bg-slate-800 border border-slate-700';
          } else if (tileType === TILE.VOID_ONLY) {
            // Void-only path
            if (game.dimension === 'void') {
              tile.className += ' bg-purple-900/50 border border-purple-500/30';
            } else {
              tile.className += ' bg-slate-800/50 border border-slate-700/30 opacity-50';
            }
          } else if (tileType === TILE.LIGHT_ONLY) {
            // Light-only path
            if (game.dimension === 'light') {
              tile.className += ' bg-amber-900/50 border border-amber-500/30';
            } else {
              tile.className += ' bg-slate-800/50 border border-slate-700/30 opacity-50';
            }
          } else if (tileType === TILE.VOID_WALL) {
            // Wall in void, passable in light
            if (game.dimension === 'void') {
              tile.className += ' bg-slate-800 border border-purple-500/30';
            } else {
              tile.className += ' bg-slate-900/30 border border-slate-700/30';
            }
          } else if (tileType === TILE.LIGHT_WALL) {
            // Wall in light, passable in void
            if (game.dimension === 'light') {
              tile.className += ' bg-slate-800 border border-amber-500/30';
            } else {
              tile.className += ' bg-slate-900/30 border border-slate-700/30';
            }
          } else {
            // Empty
            tile.className += ' bg-slate-900/50 border border-slate-800/50 hover:border-purple-500/30';
          }

          container.appendChild(tile);
        }
      }
    }

    function isTilePassable(x, y) {
      if (x < 0 || x >= game.gridSize || y < 0 || y >= game.gridSize) return false;

      const tile = game.grid[y][x];

      if (tile === TILE.WALL) return false;
      if (tile === TILE.VOID_ONLY && game.dimension !== 'void') return false;
      if (tile === TILE.LIGHT_ONLY && game.dimension !== 'light') return false;
      if (tile === TILE.VOID_WALL && game.dimension === 'void') return false;
      if (tile === TILE.LIGHT_WALL && game.dimension === 'light') return false;

      return true;
    }

    function tryMove(targetX, targetY) {
      const dx = targetX - game.playerPos.x;
      const dy = targetY - game.playerPos.y;

      // Only allow adjacent moves (including diagonal)
      if (Math.abs(dx) > 1 || Math.abs(dy) > 1) return;
      if (dx === 0 && dy === 0) return;

      // Check if target is passable
      if (!isTilePassable(targetX, targetY)) return;

      // Move player
      game.playerPos.x = targetX;
      game.playerPos.y = targetY;
      game.moves++;

      updateUI();
      renderGrid();

      // Check win condition
      if (game.playerPos.x === game.goalPos.x && game.playerPos.y === game.goalPos.y) {
        setTimeout(showLevelComplete, 300);
      }
    }

    function handleKeyDown(e) {
      let dx = 0, dy = 0;

      switch(e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
          dy = -1;
          break;
        case 'ArrowDown':
        case 's':
        case 'S':
          dy = 1;
          break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          dx = -1;
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          dx = 1;
          break;
        case ' ':
        case 'Shift':
          shiftDimension();
          return;
        case 'r':
        case 'R':
          resetLevel();
          return;
        default:
          return;
      }

      e.preventDefault();
      tryMove(game.playerPos.x + dx, game.playerPos.y + dy);
    }

    function shiftDimension() {
      game.dimension = game.dimension === 'void' ? 'light' : 'void';

      // Visual feedback
      const container = document.getElementById('gameContainer');
      container.classList.add('shifting');
      setTimeout(() => container.classList.remove('shifting'), 500);

      // Update overlay
      const overlay = document.getElementById('shiftOverlay');
      overlay.style.opacity = '1';
      setTimeout(() => overlay.style.opacity = '0', 200);

      updateUI();
      renderGrid();
    }

    function resetLevel() {
      loadLevel(game.level);
    }

    function showLevelComplete() {
      document.getElementById('completeMoves').textContent = game.moves;
      document.getElementById('levelCompleteModal').classList.remove('hidden');

      // Save progress
      saveProgress();
    }

    function nextLevel() {
      document.getElementById('levelCompleteModal').classList.add('hidden');
      loadLevel(game.level + 1);
    }

    function updateUI() {
      document.getElementById('levelDisplay').textContent = game.level;
      document.getElementById('movesDisplay').textContent = game.moves;

      const dimIndicator = document.getElementById('dimensionIndicator');
      const dimDisplay = document.getElementById('dimensionDisplay');

      if (game.dimension === 'void') {
        dimIndicator.className = 'px-4 py-2 rounded-xl bg-purple-500/20 border border-purple-500/30';
        dimDisplay.className = 'text-lg font-bold text-purple-400 font-mono';
        dimDisplay.textContent = 'VOID';
      } else {
        dimIndicator.className = 'px-4 py-2 rounded-xl bg-amber-500/20 border border-amber-500/30';
        dimDisplay.className = 'text-lg font-bold text-amber-400 font-mono';
        dimDisplay.textContent = 'LIGHT';
      }
    }

    function saveProgress() {
      const player = JSON.parse(localStorage.getItem('arcanea-player') || '{"xp":0,"level":1,"games":{}}');

      if (!player.games['void-shift']) {
        player.games['void-shift'] = { levelsCompleted: 0, totalMoves: 0 };
      }

      player.games['void-shift'].levelsCompleted = Math.max(
        player.games['void-shift'].levelsCompleted,
        game.level
      );
      player.games['void-shift'].totalMoves += game.moves;

      // XP reward
      const xpGained = 100 + (50 * game.level) - (game.moves * 2);
      player.xp = (player.xp || 0) + Math.max(50, xpGained);

      localStorage.setItem('arcanea-player', JSON.stringify(player));
    }

    // Start
    init();
  </script>
</body>
</html>
